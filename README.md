# Soft_lab8



گزارش نهایی
بخش اول - پیاده‌سازی الگوی Adapter
زیر بخش 1 - انتخاب نوع Adapter
در این پروژه از Object Scope برای پیاده‌سازی الگوی Adapter استفاده شده است. دلیل این انتخاب، قابلیت انعطاف‌پذیری بیشتر آن در تغییرات آتی است. با استفاده از Object Scope، می‌توانیم به راحتی نحوه تعامل با کتابخانه‌های مختلف را تغییر دهیم بدون اینکه نیاز به تغییرات عمده در سایر بخش‌های برنامه باشد. در مقابل، استفاده از Class Scope می‌تواند موجب وابستگی قوی‌تر به یک پیاده‌سازی خاص شود که در صورت تغییر کتابخانه، نیاز به بازنگری در کدهای بیشتری خواهد بود.
زیر بخش 2 - نحوه پیاده‌سازی الگو
برای پیاده‌سازی الگوی Adapter، یک کلاس به نام GraphAdapter ایجاد شد که وظیفه مدیریت تعاملات با کتابخانه گراف (JUNG یا JGraphT) را بر عهده دارد. این کلاس متدی برای دریافت همسایه‌های یک گره فراهم می‌کند و به این ترتیب، کلاس‌های پیمایش DFS و BFS می‌توانند به سادگی از این Adapter استفاده کنند. این طراحی باعث می‌شود که در صورت تغییر کتابخانه، تنها نیاز به تغییرات در کلاس GraphAdapter باشد و سایر کلاس‌ها بدون تغییر باقی بمانند.

بخش دوم - تغییر کتابخانه
زیر بخش 1 - گزارشی از چگونگی تغییر کتابخانه
تغییر کتابخانه از JUNG به JGraphT با اضافه کردن وابستگی جدید JGraphT به فایل pom.xml پروژه آغاز شد. سپس، کلاس GraphAdapter برای فراهم کردن واسطی میان API JUNG و JGraphT ایجاد گردید. در این Adapter، متدها و ساختارهای مورد نیاز برای پیاده‌سازی پیمایش‌ها در JGraphT به‌روزرسانی شدند. پس از این تغییرات، کلاس‌های پیمایش DFS و BFS بدون تغییر باقی ماندند و به کمک Adapter به کار خود ادامه دادند.
زیر بخش 2 - تغییرات ناشی از تغییر کتابخانه از JUNG به JGraphT
با تغییر کتابخانه به JGraphT، تغییرات عمده‌ای در نحوه مدیریت گراف و متدهای مربوط به آن ایجاد شد. به عنوان مثال، در JGraphT، نحوه تعریف و ایجاد گراف‌ها و همچنین روش‌های دریافت همسایه‌ها و اضافه کردن یال‌ها تغییر کرده است. این تغییرات در کلاس GraphAdapter اعمال شد، در حالی که کلاس‌های پیمایش (DFS و BFS) تغییری در منطق خود نداشتند. این امر موجب کاهش وابستگی به جزئیات پیاده‌سازی کتابخانه خاص شد.

بخش سوم - تحلیل الگوی استراتژی
تحلیل وجود الگوی Strategy
1. استفاده از این الگو به چه علتی قابل قبول است؟
استفاده از الگوی Strategy در این پروژه به دلیل افزایش انعطاف‌پذیری و قابلیت نگهداری کد قابل قبول است. این الگو به توسعه‌دهندگان این امکان را می‌دهد که روش‌های مختلف پیمایش (مانند DFS و BFS) را به صورت مستقل پیاده‌سازی کنند و در هر زمان بدون تغییر در منطق اصلی برنامه، استراتژی پیمایش را تغییر دهند.

2. روش تحقق این الگو
برای تحقق الگوی Strategy، یک واسط به نام Traverser تعریف شده است که متد traverse را به عنوان قرار داد ارائه می‌دهد. سپس، کلاس‌های DfsGraphTraverser و BfsGraphTraverser هر کدام به‌صورت مستقل از این واسط پیاده‌سازی شده‌اند. با این طراحی، می‌توان به راحتی استراتژی‌های جدید را اضافه کرد یا تغییر داد بدون اینکه نیاز به تغییر در سایر قسمت‌های کد باشد.
